(window.webpackJsonp=window.webpackJsonp||[]).push([[50],{362:function(t,_,v){"use strict";v.r(_);var l=v(7),a=Object(l.a)({},(function(){var t=this,_=t._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h1",{attrs:{id:"小程序数据绑定"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#小程序数据绑定"}},[t._v("#")]),t._v(" 小程序数据绑定")]),t._v(" "),_("h2",{attrs:{id:"_1-c-create-创建"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-c-create-创建"}},[t._v("#")]),t._v(" 1.C(Create-创建)")]),t._v(" "),_("ol",[_("li",[_("p",[t._v("Vue")]),t._v(" "),_("ol",[_("li",[_("p",[t._v("写在配置对象的data函数中,data函数返回一个状态对象")])]),t._v(" "),_("li",[_("p",[_("strong",[t._v("问题:Vue为什么data必须是一个函数?")])]),t._v(" "),_("ol",[_("li",[_("p",[_("strong",[t._v("从开始拆分组件,也就是使用脚手架开始,就只能写成函数了")])])]),t._v(" "),_("li",[_("p",[_("strong",[t._v("data中应该存放的是当前组件独享的数据,VueX中应该存放的是多个组件共享的状态数据")])])]),t._v(" "),_("li",[_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[t._v("<template>\n\t<!- 虽然以下三个A显示内容相同,但是是三个不同的实例对象 ->\n\t<A/>\n\t<A/>\n\t<A/>\n</tempplate>\n<script>\n\timport A  from './A.vue';\n\texport default {\n\t\tcomponents:{\n          A\n\t\t}\n\t}\n<\/script>\n\n")])])]),_("p",[t._v("​")])]),t._v(" "),_("li",[_("p",[_("strong",[t._v("如果data是一个对象的话,那么生成的所有组件实例对象会共享这一个data对象,导致一个组件修改数据所有组件一起发生变化,所以data必须是一个工厂函数,用于在每次创建组件实例对象的时候,自动返回一个全新的data对象")])])])])])])]),t._v(" "),_("li",[_("p",[t._v("React")]),t._v(" "),_("ol",[_("li",[t._v("在class中书写state={}即可")])])]),t._v(" "),_("li",[_("p",[t._v("小程序")]),t._v(" "),_("ol",[_("li",[_("strong",[t._v("在配置对象中添加属性data,属性值的数据类型是对象")])]),t._v(" "),_("li",[t._v("问题:为什么小程序的data可以是对象,他难道不怕多个实例对象共享一个data吗?\n"),_("ol",[_("li",[t._v("因为小程序在接收到data的时候,会将其使用JSON进行一波深拷贝,每次得到的都是一个全新的data对象")])])])])])]),t._v(" "),_("h2",{attrs:{id:"_2-r-read-读取"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-r-read-读取"}},[t._v("#")]),t._v(" 2.R(Read-读取)")]),t._v(" "),_("ol",[_("li",[t._v("模版\n"),_("ol",[_("li",[t._v("Vue\n"),_("ol",[_("li",[t._v("在template中使用插值语法实现展示("+t._s(t.msg)+")")]),t._v(" "),_("li",[t._v("问题:什么情况下需要使用插值语法?\n"),_("ol",[_("li",[t._v("如果想要将data数据当做文本显示,需要使用插值语法")]),t._v(" "),_("li",[t._v("将data数据当作标签属性或者指令的值时,不需要使用插值语法")])])])])]),t._v(" "),_("li",[t._v("React\n"),_("ol",[_("li",[t._v("在render函数中,使用{this.state.msg}即可展示")])])]),t._v(" "),_("li",[t._v("小程序\n"),_("ol",[_("li",[_("strong",[t._v("在wxml中使用插值语法即可展示")])]),t._v(" "),_("li",[_("strong",[t._v("注意:只要想在wxml中使用data数据,一定要加插值语法")])])])])])]),t._v(" "),_("li",[t._v("js代码\n"),_("ol",[_("li",[t._v("Vue\n"),_("ol",[_("li",[t._v("语法:this.msg")]),t._v(" "),_("li",[t._v("流程:\n"),_("ol",[_("li",[t._v("通过this.msg读取结果,触发数据代理的get方法")]),t._v(" "),_("li",[t._v("由于触发了数据代理,所以会自动读取this.$data.msg的数据,又会触发数据劫持的get方法")]),t._v(" "),_("li",[t._v("最终通过数据劫持操作的get,可以获取到对应的数据进行返回使用")])])])])]),t._v(" "),_("li",[t._v("React\n"),_("ol",[_("li",[t._v("语法:this.state.msg")]),t._v(" "),_("li",[t._v("因为React没有数据代理,所以只能自己老老实实找到state读取数据")])])]),t._v(" "),_("li",[t._v("小程序\n"),_("ol",[_("li",[_("strong",[t._v("语法:this.data.msg")])]),t._v(" "),_("li",[_("strong",[t._v("注意:小程序没有数据代理,所以只能自己找到data进行读取")])])])])])])]),t._v(" "),_("h2",{attrs:{id:"_3-u-update-更新"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-u-update-更新"}},[t._v("#")]),t._v(" 3.U(Update-更新)")]),t._v(" "),_("ol",[_("li",[t._v("Vue\n"),_("ol",[_("li",[t._v("Vue的特点:响应式特点(数据驱动)\n"),_("ol",[_("li",[t._v("响应式:修改数据,视图也跟着发生变化\n"),_("ol",[_("li",[t._v("当数据发生变化的时候,视图会重新渲染,展示最新结果")])])])])]),t._v(" "),_("li",[t._v('语法:this.msg = "我是修改之后的数据"')]),t._v(" "),_("li",[t._v("流程:\n"),_("ol",[_("li",[t._v("对this.msg进行赋值操作,会触发"),_("strong",[t._v("数据代理")]),t._v("的set方法")]),t._v(" "),_("li",[t._v("数据代理会对this.$data.msg进行赋值操作,从而触发"),_("strong",[t._v("数据劫持")]),t._v("的set方法")]),t._v(" "),_("li",[t._v("set方法中缓存的属性值会被修改")]),t._v(" "),_("li",[t._v("在set方法触发的最后,会调用dep.notify方法通知"),_("strong",[t._v("视图进行更新")])])])]),t._v(" "),_("li",[_("strong",[t._v("面试题1:Vue中数据更新是同步更新还是异步更新?")]),t._v(" "),_("ol",[_("li",[_("strong",[t._v("同步更新")])])])]),t._v(" "),_("li",[_("strong",[t._v("面试题2:Vue中视图更新是同步更新还是异步更新?")]),t._v(" "),_("ol",[_("li",[_("strong",[t._v("异步更新(通过Vue后台管理系统中的编辑模式切换可以观察到该现象)")])])])])])]),t._v(" "),_("li",[t._v("React\n"),_("ol",[_("li",[t._v("前言:React没有响应式操作,所以大家都称他为持久化状态框架\n"),_("ol",[_("li",[t._v("说白了,你直接去操作this.state中存储的数据,不会导致视图更新")])])]),t._v(" "),_("li",[t._v('语法:this.setState({msg:"我是修改之后的数据"})')]),t._v(" "),_("li",[t._v("面试题:React中数据更新是同步更新还是异步更新?\n"),_("ol",[_("li",[t._v("异步更新")])])])])]),t._v(" "),_("li",[t._v("小程序\n"),_("ol",[_("li",[_("strong",[t._v('语法:this.setData({ msg:"我是修改之后的数据"})')])]),t._v(" "),_("li",[_("strong",[t._v("注意:")]),t._v(" "),_("ol",[_("li",[_("strong",[t._v("小程序没有数据劫持.所以无法实现响应式效果")])]),t._v(" "),_("li",[_("strong",[t._v("面试题1:小程序中数据更新是同步更新还是异步更新?")]),t._v(" "),_("ol",[_("li",[_("strong",[t._v("同步更新")])])])]),t._v(" "),_("li",[_("strong",[t._v("面试题2:小程序中视图更新是同步更新还是异步更新?")]),t._v(" "),_("ol",[_("li",[_("strong",[t._v("异步更新")])])])])])])])]),t._v(" "),_("li",[_("strong",[t._v("总结问题:为什么所有的框架的视图更新都要是异步更新?")]),t._v(" "),_("ol",[_("li",[_("strong",[t._v("节流是一定时间内如果可能调用多次函数,则第一次为准,其余不执行(登录按钮节流)")])]),t._v(" "),_("li",[_("strong",[t._v("防抖是一定时间内如果可能调用多次函数,则以最后一次为准,其余不执行(搜索框单词联想防抖)")])]),t._v(" "),_("li",[_("strong",[t._v("数据时效性:节流的时效性极差,防抖的时效性极好")])]),t._v(" "),_("li",[_("strong",[t._v("函数执行时机:节流的函数会立即执行第一次,而防抖的函数会延迟一段时间执行")])]),t._v(" "),_("li",[_("strong",[t._v("异步更新视图就相当于是对视图的多次更新实现了防抖操作,可以减少视图更新的次数,加快渲染速度")])])])])]),t._v(" "),_("h2",{attrs:{id:"_4-d-delete-删除"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-d-delete-删除"}},[t._v("#")]),t._v(" 4.D(Delete-删除)")]),t._v(" "),_("ol",[_("li",[t._v("Vue\n"),_("ol",[_("li",[t._v("this.$delete和Vue.delete")]),t._v(" "),_("li",[t._v("在Vue2中,需要使用以上两个API来删除响应式属性,才能重新渲染页面")])])]),t._v(" "),_("li",[t._v("React")]),t._v(" "),_("li",[t._v("小程序\n"),_("ol",[_("li",[t._v("React和小程序都没有响应式操作,所以不需要使用特殊语法进行删除,只要更新成undefined即可")])])])]),t._v(" "),_("h2",{attrs:{id:"_5-数据流向"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_5-数据流向"}},[t._v("#")]),t._v(" 5.数据流向")]),t._v(" "),_("ol",[_("li",[_("p",[t._v("Vue")]),t._v(" "),_("ol",[_("li",[t._v("单向")]),t._v(" "),_("li",[t._v("Vue中有一个东西叫做双向数据绑定\n"),_("ol",[_("li",[t._v("指令:v-model")])])])])]),t._v(" "),_("li",[_("p",[t._v("React")]),t._v(" "),_("ol",[_("li",[t._v("单向")])])]),t._v(" "),_("li",[_("p",[t._v("小程序")]),t._v(" "),_("ol",[_("li",[t._v("单向")])])]),t._v(" "),_("li",[_("p",[t._v("v-model指令分析")]),t._v(" "),_("ol",[_("li",[t._v("效果:\n"),_("ol",[_("li",[t._v("将状态数据的值作为input框的默认值进行展示")]),t._v(" "),_("li",[t._v("当用户修改输入框的内容时,同步修改data中对应")])])])]),t._v(" "),_("p",[t._v("​")])])])])}),[],!1,null,null,null);_.default=a.exports}}]);