(window.webpackJsonp=window.webpackJsonp||[]).push([[41],{351:function(a,n,t){"use strict";t.r(n);var s=t(7),e=Object(s.a)({},(function(){var a=this,n=a._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[n("h1",{attrs:{id:"元组"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#元组"}},[a._v("#")]),a._v(" 元组")]),a._v(" "),n("p",[a._v("数组合并了相同类型的数据，而元组（Tuple）合并了不同类型的数据。")]),a._v(" "),n("h2",{attrs:{id:"例如"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#例如"}},[a._v("#")]),a._v(" 例如")]),a._v(" "),n("p",[a._v("定义一对值分别为 "),n("code",[a._v("string")]),a._v(" 和 "),n("code",[a._v("number")]),a._v(" 的元组：")]),a._v(" "),n("div",{staticClass:"language-Plain Text extra-class"},[n("pre",{pre:!0,attrs:{class:"language-plain"}},[n("code",[a._v("let tom: [string, number] = ['Tom', 25];\n")])])]),n("p",[a._v("当赋值或访问一个已知索引的元素时，会得到正确的类型：")]),a._v(" "),n("div",{staticClass:"language-Plain Text extra-class"},[n("pre",{pre:!0,attrs:{class:"language-plain"}},[n("code",[a._v("let tom: [string, number];\ntom[0] = 'Tom';\ntom[1] = 25;\n\ntom[0].slice(1);\ntom[1].toFixed(2);\n")])])]),n("p",[a._v("也可以只赋值其中一项：")]),a._v(" "),n("div",{staticClass:"language-Plain Text extra-class"},[n("pre",{pre:!0,attrs:{class:"language-plain"}},[n("code",[a._v("let tom: [string, number];\ntom[0] = 'Tom';\n")])])]),n("p",[a._v("但是当直接对元组类型的变量进行初始化或者赋值的时候，需要提供所有元组类型中指定的项。")]),a._v(" "),n("div",{staticClass:"language-Plain Text extra-class"},[n("pre",{pre:!0,attrs:{class:"language-plain"}},[n("code",[a._v("let tom: [string, number];\ntom = ['Tom', 25];\n")])])]),n("div",{staticClass:"language-Plain Text extra-class"},[n("pre",{pre:!0,attrs:{class:"language-plain"}},[n("code",[a._v("let tom: [string, number];\ntom = ['Tom'];\n\n// Property '1' is missing in type '[string]' but required in type '[string, number]'.\n")])])]),n("h2",{attrs:{id:"越界的元素"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#越界的元素"}},[a._v("#")]),a._v(" 越界的元素")]),a._v(" "),n("p",[a._v("当添加越界的元素时，它的类型会被限制为元组中每个类型的联合类型：")]),a._v(" "),n("div",{staticClass:"language-Plain Text extra-class"},[n("pre",{pre:!0,attrs:{class:"language-plain"}},[n("code",[a._v("let tom: [string, number];\ntom = ['Tom', 25];\ntom.push('male');\ntom.push(true);\n\n// Argument of type 'true' is not assignable to parameter of type 'string | number'.\n")])])]),n("h1",{attrs:{id:"枚举"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#枚举"}},[a._v("#")]),a._v(" 枚举")]),a._v(" "),n("p",[a._v("枚举（Enum）类型用于取值被限定在一定范围内的场景，比如一周只能有七天，颜色限定为红绿蓝等。")]),a._v(" "),n("h2",{attrs:{id:"简单的例子"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#简单的例子"}},[a._v("#")]),a._v(" 简单的例子")]),a._v(" "),n("p",[a._v("枚举使用 "),n("code",[a._v("enum")]),a._v(" 关键字来定义：")]),a._v(" "),n("div",{staticClass:"language-Plain Text extra-class"},[n("pre",{pre:!0,attrs:{class:"language-plain"}},[n("code",[a._v("enum Days {Sun, Mon, Tue, Wed, Thu, Fri, Sat};\n")])])]),n("p",[a._v("枚举成员会被赋值为从 "),n("code",[a._v("0")]),a._v(" 开始递增的数字，同时也会对枚举值到枚举名进行反向映射：")]),a._v(" "),n("div",{staticClass:"language-Plain Text extra-class"},[n("pre",{pre:!0,attrs:{class:"language-plain"}},[n("code",[a._v('enum Days {Sun, Mon, Tue, Wed, Thu, Fri, Sat};\n\nconsole.log(Days["Sun"] === 0); // true\nconsole.log(Days["Mon"] === 1); // true\nconsole.log(Days["Tue"] === 2); // true\nconsole.log(Days["Sat"] === 6); // true\n\nconsole.log(Days[0] === "Sun"); // true\nconsole.log(Days[1] === "Mon"); // true\nconsole.log(Days[2] === "Tue"); // true\nconsole.log(Days[6] === "Sat"); // true\n')])])]),n("p",[a._v("事实上，上面的例子会被编译为：")]),a._v(" "),n("div",{staticClass:"language-JavaScript extra-class"},[n("pre",{pre:!0,attrs:{class:"language-javascript"}},[n("code",[n("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("var")]),a._v(" Days"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),n("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("function")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),n("span",{pre:!0,attrs:{class:"token parameter"}},[a._v("Days")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    Days"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),a._v("Days"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),n("span",{pre:!0,attrs:{class:"token string"}},[a._v('"Sun"')]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token number"}},[a._v("0")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token string"}},[a._v('"Sun"')]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    Days"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),a._v("Days"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),n("span",{pre:!0,attrs:{class:"token string"}},[a._v('"Mon"')]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token number"}},[a._v("1")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token string"}},[a._v('"Mon"')]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    Days"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),a._v("Days"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),n("span",{pre:!0,attrs:{class:"token string"}},[a._v('"Tue"')]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token number"}},[a._v("2")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token string"}},[a._v('"Tue"')]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    Days"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),a._v("Days"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),n("span",{pre:!0,attrs:{class:"token string"}},[a._v('"Wed"')]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token number"}},[a._v("3")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token string"}},[a._v('"Wed"')]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    Days"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),a._v("Days"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),n("span",{pre:!0,attrs:{class:"token string"}},[a._v('"Thu"')]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token number"}},[a._v("4")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token string"}},[a._v('"Thu"')]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    Days"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),a._v("Days"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),n("span",{pre:!0,attrs:{class:"token string"}},[a._v('"Fri"')]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token number"}},[a._v("5")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token string"}},[a._v('"Fri"')]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    Days"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),a._v("Days"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),n("span",{pre:!0,attrs:{class:"token string"}},[a._v('"Sat"')]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token number"}},[a._v("6")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token string"}},[a._v('"Sat"')]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("Days "),n("span",{pre:!0,attrs:{class:"token operator"}},[a._v("||")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("Days "),n("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n")])])]),n("h2",{attrs:{id:"手动赋值"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#手动赋值"}},[a._v("#")]),a._v(" 手动赋值")]),a._v(" "),n("p",[a._v("我们也可以给枚举项手动赋值：")]),a._v(" "),n("div",{staticClass:"language-Plain Text extra-class"},[n("pre",{pre:!0,attrs:{class:"language-plain"}},[n("code",[a._v('enum Days {Sun = 7, Mon = 1, Tue, Wed, Thu, Fri, Sat};\n\nconsole.log(Days["Sun"] === 7); // true\nconsole.log(Days["Mon"] === 1); // true\nconsole.log(Days["Tue"] === 2); // true\nconsole.log(Days["Sat"] === 6); // true\n')])])]),n("p",[a._v("上面的例子中，未手动赋值的枚举项会接着上一个枚举项递增。")]),a._v(" "),n("p",[a._v("如果未手动赋值的枚举项与手动赋值的重复了，TypeScript 是不会察觉到这一点的：")]),a._v(" "),n("div",{staticClass:"language-Plain Text extra-class"},[n("pre",{pre:!0,attrs:{class:"language-plain"}},[n("code",[a._v('enum Days {Sun = 3, Mon = 1, Tue, Wed, Thu, Fri, Sat};\n\nconsole.log(Days["Sun"] === 3); // true\nconsole.log(Days["Wed"] === 3); // true\nconsole.log(Days[3] === "Sun"); // false\nconsole.log(Days[3] === "Wed"); // true\n')])])]),n("p",[a._v("上面的例子中，递增到 "),n("code",[a._v("3")]),a._v(" 的时候与前面的 "),n("code",[a._v("Sun")]),a._v(" 的取值重复了，但是 TypeScript 并没有报错，导致 "),n("code",[a._v("Days[3]")]),a._v(" 的值先是 "),n("code",[a._v('"Sun"')]),a._v("，而后又被 "),n("code",[a._v('"Wed"')]),a._v(" 覆盖了。编译的结果是：")]),a._v(" "),n("div",{staticClass:"language-JavaScript extra-class"},[n("pre",{pre:!0,attrs:{class:"language-javascript"}},[n("code",[n("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("var")]),a._v(" Days"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),n("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("function")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),n("span",{pre:!0,attrs:{class:"token parameter"}},[a._v("Days")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    Days"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),a._v("Days"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),n("span",{pre:!0,attrs:{class:"token string"}},[a._v('"Sun"')]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token number"}},[a._v("3")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token string"}},[a._v('"Sun"')]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    Days"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),a._v("Days"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),n("span",{pre:!0,attrs:{class:"token string"}},[a._v('"Mon"')]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token number"}},[a._v("1")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token string"}},[a._v('"Mon"')]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    Days"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),a._v("Days"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),n("span",{pre:!0,attrs:{class:"token string"}},[a._v('"Tue"')]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token number"}},[a._v("2")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token string"}},[a._v('"Tue"')]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    Days"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),a._v("Days"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),n("span",{pre:!0,attrs:{class:"token string"}},[a._v('"Wed"')]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token number"}},[a._v("3")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token string"}},[a._v('"Wed"')]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    Days"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),a._v("Days"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),n("span",{pre:!0,attrs:{class:"token string"}},[a._v('"Thu"')]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token number"}},[a._v("4")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token string"}},[a._v('"Thu"')]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    Days"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),a._v("Days"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),n("span",{pre:!0,attrs:{class:"token string"}},[a._v('"Fri"')]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token number"}},[a._v("5")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token string"}},[a._v('"Fri"')]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    Days"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),a._v("Days"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),n("span",{pre:!0,attrs:{class:"token string"}},[a._v('"Sat"')]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token number"}},[a._v("6")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token string"}},[a._v('"Sat"')]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("Days "),n("span",{pre:!0,attrs:{class:"token operator"}},[a._v("||")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("Days "),n("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n")])])]),n("p",[a._v("所以使用的时候需要注意，最好不要出现这种覆盖的情况。")]),a._v(" "),n("h1",{attrs:{id:"类"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#类"}},[a._v("#")]),a._v(" 类")]),a._v(" "),n("h2",{attrs:{id:"typescript-中类的用法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#typescript-中类的用法"}},[a._v("#")]),a._v(" TypeScript 中类的用法")]),a._v(" "),n("h3",{attrs:{id:"public-private-和-protected"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#public-private-和-protected"}},[a._v("#")]),a._v(" public private 和 protected")]),a._v(" "),n("p",[a._v("TypeScript 可以使用三种访问修饰符（Access Modifiers），分别是 "),n("code",[a._v("public")]),a._v("、"),n("code",[a._v("private")]),a._v(" 和 "),n("code",[a._v("protected")]),a._v("。")]),a._v(" "),n("ul",[n("li",[n("p",[n("code",[a._v("public")]),a._v(" 修饰的属性或方法是公有的，可以在任何地方被访问到，默认所有的属性和方法都是 "),n("code",[a._v("public")]),a._v(" 的")])]),a._v(" "),n("li",[n("p",[n("code",[a._v("private")]),a._v(" 修饰的属性或方法是私有的，不能在声明它的类的外部访问")])]),a._v(" "),n("li",[n("p",[n("code",[a._v("protected")]),a._v(" 修饰的属性或方法是受保护的，它和 "),n("code",[a._v("private")]),a._v(" 类似，区别是它在子类中也是允许被访问的")])])]),a._v(" "),n("p",[a._v("下面举一些例子：")]),a._v(" "),n("div",{staticClass:"language-Plain Text extra-class"},[n("pre",{pre:!0,attrs:{class:"language-plain"}},[n("code",[a._v("class Animal {\n  public name;\n  public constructor(name) {\n    this.name = name;\n  }\n}\n\nlet a = new Animal('Jack');\nconsole.log(a.name); // Jack\na.name = 'Tom';\nconsole.log(a.name); // Tom\n")])])]),n("p",[a._v("上面的例子中，"),n("code",[a._v("name")]),a._v(" 被设置为了 "),n("code",[a._v("public")]),a._v("，所以直接访问实例的 "),n("code",[a._v("name")]),a._v(" 属性是允许的。")]),a._v(" "),n("p",[a._v("很多时候，我们希望有的属性是无法直接存取的，这时候就可以用 "),n("code",[a._v("private")]),a._v(" 了：")]),a._v(" "),n("div",{staticClass:"language-Plain Text extra-class"},[n("pre",{pre:!0,attrs:{class:"language-plain"}},[n("code",[a._v("class Animal {\n  private name;\n  public constructor(name) {\n    this.name = name;\n  }\n}\n\nlet a = new Animal('Jack');\nconsole.log(a.name);\na.name = 'Tom';\n\n// index.ts(9,13): error TS2341: Property 'name' is private and only accessible within class 'Animal'.\n// index.ts(10,1): error TS2341: Property 'name' is private and only accessible within class 'Animal'.\n")])])]),n("p",[a._v("需要注意的是，TypeScript 编译之后的代码中，并没有限制 "),n("code",[a._v("private")]),a._v(" 属性在外部的可访问性。")]),a._v(" "),n("p",[a._v("上面的例子编译后的代码是：")]),a._v(" "),n("div",{staticClass:"language-JavaScript extra-class"},[n("pre",{pre:!0,attrs:{class:"language-javascript"}},[n("code",[n("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("var")]),a._v(" Animal "),n("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),n("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("function")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n  "),n("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("function")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[a._v("Animal")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),n("span",{pre:!0,attrs:{class:"token parameter"}},[a._v("name")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    "),n("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("this")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("name "),n("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" name"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n  "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n  "),n("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("return")]),a._v(" Animal"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),n("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("var")]),a._v(" a "),n("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("new")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Animal")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),n("span",{pre:!0,attrs:{class:"token string"}},[a._v("'Jack'")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\nconsole"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[a._v("log")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("a"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("name"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\na"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("name "),n("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token string"}},[a._v("'Tom'")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n")])])]),n("p",[a._v("使用 "),n("code",[a._v("private")]),a._v(" 修饰的属性或方法，在子类中也是不允许访问的：")]),a._v(" "),n("div",{staticClass:"language-Plain Text extra-class"},[n("pre",{pre:!0,attrs:{class:"language-plain"}},[n("code",[a._v("class Animal {\n  private name;\n  public constructor(name) {\n    this.name = name;\n  }\n}\n\nclass Cat extends Animal {\n  constructor(name) {\n    super(name);\n    console.log(this.name);\n  }\n}\n\n// index.ts(11,17): error TS2341: Property 'name' is private and only accessible within class 'Animal'.\n")])])]),n("p",[a._v("而如果是用 "),n("code",[a._v("protected")]),a._v(" 修饰，则允许在子类中访问：")]),a._v(" "),n("div",{staticClass:"language-Plain Text extra-class"},[n("pre",{pre:!0,attrs:{class:"language-plain"}},[n("code",[a._v("class Animal {\n  protected name;\n  public constructor(name) {\n    this.name = name;\n  }\n}\n\nclass Cat extends Animal {\n  constructor(name) {\n    super(name);\n    console.log(this.name);\n  }\n}\n")])])]),n("p",[a._v("当构造函数修饰为 "),n("code",[a._v("private")]),a._v(" 时，该类不允许被继承或者实例化：")]),a._v(" "),n("div",{staticClass:"language-Plain Text extra-class"},[n("pre",{pre:!0,attrs:{class:"language-plain"}},[n("code",[a._v("class Animal {\n  public name;\n  private constructor(name) {\n    this.name = name;\n  }\n}\nclass Cat extends Animal {\n  constructor(name) {\n    super(name);\n  }\n}\n\nlet a = new Animal('Jack');\n\n// index.ts(7,19): TS2675: Cannot extend a class 'Animal'. Class constructor is marked as private.\n// index.ts(13,9): TS2673: Constructor of class 'Animal' is private and only accessible within the class declaration.\n")])])]),n("p",[a._v("当构造函数修饰为 "),n("code",[a._v("protected")]),a._v(" 时，该类只允许被继承：")]),a._v(" "),n("div",{staticClass:"language-Plain Text extra-class"},[n("pre",{pre:!0,attrs:{class:"language-plain"}},[n("code",[a._v("class Animal {\n  public name;\n  protected constructor(name) {\n    this.name = name;\n  }\n}\nclass Cat extends Animal {\n  constructor(name) {\n    super(name);\n  }\n}\n\nlet a = new Animal('Jack');\n\n// index.ts(13,9): TS2674: Constructor of class 'Animal' is protected and only accessible within the class declaration.\n")])])]),n("h3",{attrs:{id:"参数属性"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#参数属性"}},[a._v("#")]),a._v(" 参数属性")]),a._v(" "),n("p",[a._v("修饰符和"),n("code",[a._v("readonly")]),a._v("还可以使用在构造函数参数中，等同于类中定义该属性同时给该属性赋值，使代码更简洁。")]),a._v(" "),n("div",{staticClass:"language-Plain Text extra-class"},[n("pre",{pre:!0,attrs:{class:"language-plain"}},[n("code",[a._v("class Animal {\n  // public name: string;\n  public constructor(public name) {\n    // this.name = name;\n  }\n}\n")])])]),n("h3",{attrs:{id:"readonly"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#readonly"}},[a._v("#")]),a._v(" readonly")]),a._v(" "),n("p",[a._v("只读属性关键字，只允许出现在属性声明或索引签名或构造函数中。")]),a._v(" "),n("div",{staticClass:"language-Plain Text extra-class"},[n("pre",{pre:!0,attrs:{class:"language-plain"}},[n("code",[a._v("class Animal {\n  readonly name;\n  public constructor(name) {\n    this.name = name;\n  }\n}\n\nlet a = new Animal('Jack');\nconsole.log(a.name); // Jack\na.name = 'Tom';\n\n// index.ts(10,3): TS2540: Cannot assign to 'name' because it is a read-only property.\n")])])]),n("p",[a._v("注意如果 "),n("code",[a._v("readonly")]),a._v(" 和其他访问修饰符同时存在的话，需要写在其后面。")]),a._v(" "),n("div",{staticClass:"language-Plain Text extra-class"},[n("pre",{pre:!0,attrs:{class:"language-plain"}},[n("code",[a._v("class Animal {\n  // public readonly name;\n  public constructor(public readonly name) {\n    // this.name = name;\n  }\n}\n")])])]),n("h3",{attrs:{id:"抽象类"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#抽象类"}},[a._v("#")]),a._v(" 抽象类")]),a._v(" "),n("p",[n("code",[a._v("abstract")]),a._v(" 用于定义抽象类和其中的抽象方法。")]),a._v(" "),n("p",[a._v("什么是抽象类？")]),a._v(" "),n("p",[a._v("首先，抽象类是不允许被实例化的：")]),a._v(" "),n("div",{staticClass:"language-Plain Text extra-class"},[n("pre",{pre:!0,attrs:{class:"language-plain"}},[n("code",[a._v("abstract class Animal {\n  public name;\n  public constructor(name) {\n    this.name = name;\n  }\n  public abstract sayHi();\n}\n\nlet a = new Animal('Jack');\n\n// index.ts(9,11): error TS2511: Cannot create an instance of the abstract class 'Animal'.\n")])])]),n("p",[a._v("上面的例子中，我们定义了一个抽象类 "),n("code",[a._v("Animal")]),a._v("，并且定义了一个抽象方法 "),n("code",[a._v("sayHi")]),a._v("。在实例化抽象类的时候报错了，抽象类主要用来被子类继承。")]),a._v(" "),n("p",[a._v("其次，抽象类中的抽象方法必须被子类实现：")]),a._v(" "),n("div",{staticClass:"language-Plain Text extra-class"},[n("pre",{pre:!0,attrs:{class:"language-plain"}},[n("code",[a._v("abstract class Animal {\n  public name;\n  public constructor(name) {\n    this.name = name;\n  }\n  public abstract sayHi();\n}\n\nclass Cat extends Animal {\n  public eat() {\n    console.log(`${this.name} is eating.`);\n  }\n}\n\nlet cat = new Cat('Tom');\n\n// index.ts(9,7): error TS2515: Non-abstract class 'Cat' does not implement inherited abstract member 'sayHi' from class 'Animal'.\n")])])]),n("p",[a._v("上面的例子中，我们定义了一个类 "),n("code",[a._v("Cat")]),a._v(" 继承了抽象类 "),n("code",[a._v("Animal")]),a._v("，但是没有实现抽象方法 "),n("code",[a._v("sayHi")]),a._v("，所以编译报错了。")]),a._v(" "),n("p",[a._v("下面是一个正确使用抽象类的例子：")]),a._v(" "),n("div",{staticClass:"language-Plain Text extra-class"},[n("pre",{pre:!0,attrs:{class:"language-plain"}},[n("code",[a._v("abstract class Animal {\n  public name;\n  public constructor(name) {\n    this.name = name;\n  }\n  public abstract sayHi();\n}\n\nclass Cat extends Animal {\n  public sayHi() {\n    console.log(`Meow, My name is ${this.name}`);\n  }\n}\n\nlet cat = new Cat('Tom');\n")])])]),n("p",[a._v("上面的例子中，我们实现了抽象方法 "),n("code",[a._v("sayHi")]),a._v("，编译通过了。")]),a._v(" "),n("h2",{attrs:{id:"类的类型"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#类的类型"}},[a._v("#")]),a._v(" 类的类型")]),a._v(" "),n("p",[a._v("给类加上 TypeScript 的类型很简单，与接口类似：")]),a._v(" "),n("div",{staticClass:"language-Plain Text extra-class"},[n("pre",{pre:!0,attrs:{class:"language-plain"}},[n("code",[a._v("class Animal {\n  name: string;\n  constructor(name: string) {\n    this.name = name;\n  }\n  sayHi(): string {\n    return `My name is ${this.name}`;\n  }\n}\n\nlet a: Animal = new Animal('Jack');\nconsole.log(a.sayHi()); // My name is Jack\n")])])]),n("h1",{attrs:{id:"类与接口"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#类与接口"}},[a._v("#")]),a._v(" 类与接口")]),a._v(" "),n("p",[a._v("接口（Interfaces）可以用于对「对象的形状（Shape）」进行描述。")]),a._v(" "),n("p",[a._v("这一章主要介绍接口的另一个用途，对类的一部分行为进行抽象。")]),a._v(" "),n("h2",{attrs:{id:"类实现接口"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#类实现接口"}},[a._v("#")]),a._v(" 类实现接口")]),a._v(" "),n("p",[a._v("实现（implements）是面向对象中的一个重要概念。一般来讲，一个类只能继承自另一个类，有时候不同类之间可以有一些共有的特性，这时候就可以把特性提取成接口（interfaces），用 "),n("code",[a._v("implements")]),a._v(" 关键字来实现。这个特性大大提高了面向对象的灵活性。")]),a._v(" "),n("p",[a._v("举例来说，门是一个类，防盗门是门的子类。如果防盗门有一个报警器的功能，我们可以简单的给防盗门添加一个报警方法。这时候如果有另一个类，车，也有报警器的功能，就可以考虑把报警器提取出来，作为一个接口，防盗门和车都去实现它：")]),a._v(" "),n("div",{staticClass:"language-Plain Text extra-class"},[n("pre",{pre:!0,attrs:{class:"language-plain"}},[n("code",[a._v("interface Alarm {\n    alert(): void;\n}\n\nclass Door {\n}\n\nclass SecurityDoor extends Door implements Alarm {\n    alert() {\n        console.log('SecurityDoor alert');\n    }\n}\n\nclass Car implements Alarm {\n    alert() {\n        console.log('Car alert');\n    }\n}\n")])])]),n("p",[a._v("一个类可以实现多个接口：")]),a._v(" "),n("div",{staticClass:"language-Plain Text extra-class"},[n("pre",{pre:!0,attrs:{class:"language-plain"}},[n("code",[a._v("interface Alarm {\n    alert(): void;\n}\n\ninterface Light {\n    lightOn(): void;\n    lightOff(): void;\n}\n\nclass Car implements Alarm, Light {\n    alert() {\n        console.log('Car alert');\n    }\n    lightOn() {\n        console.log('Car light on');\n    }\n    lightOff() {\n        console.log('Car light off');\n    }\n}\n")])])]),n("p",[a._v("上例中，"),n("code",[a._v("Car")]),a._v(" 实现了 "),n("code",[a._v("Alarm")]),a._v(" 和 "),n("code",[a._v("Light")]),a._v(" 接口，既能报警，也能开关车灯。")]),a._v(" "),n("h2",{attrs:{id:"接口继承接口"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#接口继承接口"}},[a._v("#")]),a._v(" 接口继承接口")]),a._v(" "),n("p",[a._v("接口与接口之间可以是继承关系：")]),a._v(" "),n("div",{staticClass:"language-Plain Text extra-class"},[n("pre",{pre:!0,attrs:{class:"language-plain"}},[n("code",[a._v("interface Alarm {\n    alert(): void;\n}\n\ninterface LightableAlarm extends Alarm {\n    lightOn(): void;\n    lightOff(): void;\n}\n")])])]),n("p",[a._v("这很好理解，"),n("code",[a._v("LightableAlarm")]),a._v(" 继承了 "),n("code",[a._v("Alarm")]),a._v("，除了拥有 "),n("code",[a._v("alert")]),a._v(" 方法之外，还拥有两个新方法 "),n("code",[a._v("lightOn")]),a._v(" 和 "),n("code",[a._v("lightOff")]),a._v("。")]),a._v(" "),n("h2",{attrs:{id:"接口继承类"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#接口继承类"}},[a._v("#")]),a._v(" 接口继承类")]),a._v(" "),n("p",[a._v("常见的面向对象语言中，接口是不能继承类的，但是在 TypeScript 中却是可以的：")]),a._v(" "),n("div",{staticClass:"language-Plain Text extra-class"},[n("pre",{pre:!0,attrs:{class:"language-plain"}},[n("code",[a._v("class Point {\n    x: number;\n    y: number;\n    constructor(x: number, y: number) {\n        this.x = x;\n        this.y = y;\n    }\n}\n\ninterface Point3d extends Point {\n    z: number;\n}\n\nlet point3d: Point3d = {x: 1, y: 2, z: 3};\n")])])]),n("p",[a._v("为什么 TypeScript 会支持接口继承类呢？")]),a._v(" "),n("p",[a._v("实际上，当我们在声明 "),n("code",[a._v("class Point")]),a._v(" 时，除了会创建一个名为 "),n("code",[a._v("Point")]),a._v(" 的类之外，同时也创建了一个名为 "),n("code",[a._v("Point")]),a._v(" 的类型（实例的类型）。")]),a._v(" "),n("p",[a._v("所以我们既可以将 "),n("code",[a._v("Point")]),a._v(" 当做一个类来用（使用 "),n("code",[a._v("new Point")]),a._v(" 创建它的实例）：")]),a._v(" "),n("div",{staticClass:"language-Plain Text extra-class"},[n("pre",{pre:!0,attrs:{class:"language-plain"}},[n("code",[a._v("class Point {\n    x: number;\n    y: number;\n    constructor(x: number, y: number) {\n        this.x = x;\n        this.y = y;\n    }\n}\n\nconst p = new Point(1, 2);\n")])])]),n("p",[a._v("也可以将 "),n("code",[a._v("Point")]),a._v(" 当做一个类型来用（使用 "),n("code",[a._v(": Point")]),a._v(" 表示参数的类型）：")]),a._v(" "),n("div",{staticClass:"language-Plain Text extra-class"},[n("pre",{pre:!0,attrs:{class:"language-plain"}},[n("code",[a._v("class Point {\n    x: number;\n    y: number;\n    constructor(x: number, y: number) {\n        this.x = x;\n        this.y = y;\n    }\n}\n\nfunction printPoint(p: Point) {\n    console.log(p.x, p.y);\n}\n\nprintPoint(new Point(1, 2));\n")])])]),n("p",[a._v("这个例子实际上可以等价于：")]),a._v(" "),n("div",{staticClass:"language-Plain Text extra-class"},[n("pre",{pre:!0,attrs:{class:"language-plain"}},[n("code",[a._v("class Point {\n    x: number;\n    y: number;\n    constructor(x: number, y: number) {\n        this.x = x;\n        this.y = y;\n    }\n}\n\ninterface PointInstanceType {\n    x: number;\n    y: number;\n}\n\nfunction printPoint(p: PointInstanceType) {\n    console.log(p.x, p.y);\n}\n\nprintPoint(new Point(1, 2));\n")])])]),n("p",[a._v("上例中我们新声明的 "),n("code",[a._v("PointInstanceType")]),a._v(" 类型，与声明 "),n("code",[a._v("class Point")]),a._v(" 时创建的 "),n("code",[a._v("Point")]),a._v(" 类型是等价的。")]),a._v(" "),n("p",[a._v("所以回到 "),n("code",[a._v("Point3d")]),a._v(" 的例子中，我们就能很容易的理解为什么 TypeScript 会支持接口继承类了：")]),a._v(" "),n("div",{staticClass:"language-Plain Text extra-class"},[n("pre",{pre:!0,attrs:{class:"language-plain"}},[n("code",[a._v("class Point {\n    x: number;\n    y: number;\n    constructor(x: number, y: number) {\n        this.x = x;\n        this.y = y;\n    }\n}\n\ninterface PointInstanceType {\n    x: number;\n    y: number;\n}\n\n// 等价于 interface Point3d extends PointInstanceType\ninterface Point3d extends Point {\n    z: number;\n}\n\nlet point3d: Point3d = {x: 1, y: 2, z: 3};\n")])])]),n("p",[a._v("当我们声明 "),n("code",[a._v("interface Point3d extends Point")]),a._v(" 时，"),n("code",[a._v("Point3d")]),a._v(" 继承的实际上是类 "),n("code",[a._v("Point")]),a._v(" 的实例的类型。")]),a._v(" "),n("p",[a._v("换句话说，可以理解为定义了一个接口 "),n("code",[a._v("Point3d")]),a._v(" 继承另一个接口 "),n("code",[a._v("PointInstanceType")]),a._v("。")]),a._v(" "),n("p",[a._v("所以「接口继承类」和「接口继承接口」没有什么本质的区别。")]),a._v(" "),n("p",[a._v("值得注意的是，"),n("code",[a._v("PointInstanceType")]),a._v(" 相比于 "),n("code",[a._v("Point")]),a._v("，缺少了 "),n("code",[a._v("constructor")]),a._v(" 方法，这是因为声明 "),n("code",[a._v("Point")]),a._v(" 类时创建的 "),n("code",[a._v("Point")]),a._v(" 类型是不包含构造函数的。另外，除了构造函数是不包含的，静态属性或静态方法也是不包含的（实例的类型当然不应该包括构造函数、静态属性或静态方法）。")]),a._v(" "),n("p",[a._v("换句话说，声明 "),n("code",[a._v("Point")]),a._v(" 类时创建的 "),n("code",[a._v("Point")]),a._v(" 类型只包含其中的实例属性和实例方法：")]),a._v(" "),n("div",{staticClass:"language-Plain Text extra-class"},[n("pre",{pre:!0,attrs:{class:"language-plain"}},[n("code",[a._v("class Point {\n    /** 静态属性，坐标系原点 */\n    static origin = new Point(0, 0);\n    /** 静态方法，计算与原点距离 */\n    static distanceToOrigin(p: Point) {\n        return Math.sqrt(p.x * p.x + p.y * p.y);\n    }\n    /** 实例属性，x 轴的值 */\n    x: number;\n    /** 实例属性，y 轴的值 */\n    y: number;\n    /** 构造函数 */\n    constructor(x: number, y: number) {\n        this.x = x;\n        this.y = y;\n    }\n    /** 实例方法，打印此点 */\n    printPoint() {\n        console.log(this.x, this.y);\n    }\n}\n\ninterface PointInstanceType {\n    x: number;\n    y: number;\n    printPoint(): void;\n}\n\nlet p1: Point;\nlet p2: PointInstanceType;\n")])])]),n("p",[a._v("上例中最后的类型 "),n("code",[a._v("Point")]),a._v(" 和类型 "),n("code",[a._v("PointInstanceType")]),a._v(" 是等价的。")]),a._v(" "),n("p",[a._v("同样的，在接口继承类的时候，也只会继承它的实例属性和实例方法")]),a._v(" "),n("h1",{attrs:{id:"泛型"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#泛型"}},[a._v("#")]),a._v(" 泛型")]),a._v(" "),n("p",[a._v("泛型（Generics）是指在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性。")]),a._v(" "),n("h2",{attrs:{id:"简单的例子-2"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#简单的例子-2"}},[a._v("#")]),a._v(" 简单的例子")]),a._v(" "),n("p",[a._v("首先，我们来实现一个函数 "),n("code",[a._v("createArray")]),a._v("，它可以创建一个指定长度的数组，同时将每一项都填充一个默认值：")]),a._v(" "),n("div",{staticClass:"language-Plain Text extra-class"},[n("pre",{pre:!0,attrs:{class:"language-plain"}},[n("code",[a._v("function createArray(length: number, value: any): Array<any> {\n    let result = [];\n    for (let i = 0; i < length; i++) {\n        result[i] = value;\n    }\n    return result;\n}\n\ncreateArray(3, 'x'); // ['x', 'x', 'x']\n")])])]),n("p",[a._v("上例中，我们使用了来定义返回值的类型。")]),a._v(" "),n("p",[a._v("这段代码编译不会报错，但是一个显而易见的缺陷是，它并没有准确的定义返回值的类型：")]),a._v(" "),n("p",[n("code",[a._v("Array<any>")]),a._v(" 允许数组的每一项都为任意类型。但是我们预期的是，数组中每一项都应该是输入的 "),n("code",[a._v("value")]),a._v(" 的类型。")]),a._v(" "),n("p",[a._v("这时候，泛型就派上用场了：")]),a._v(" "),n("div",{staticClass:"language-Plain Text extra-class"},[n("pre",{pre:!0,attrs:{class:"language-plain"}},[n("code",[a._v("function createArray<T>(length: number, value: T): Array<T> {\n    let result: T[] = [];\n    for (let i = 0; i < length; i++) {\n        result[i] = value;\n    }\n    return result;\n}\n\ncreateArray<string>(3, 'x'); // ['x', 'x', 'x']\n")])])]),n("p",[a._v("上例中，我们在函数名后添加了 "),n("code",[a._v("<T>")]),a._v("，其中 "),n("code",[a._v("T")]),a._v(" 用来指代任意输入的类型，在后面的输入 "),n("code",[a._v("value: T")]),a._v(" 和输出 "),n("code",[a._v("Array<T>")]),a._v(" 中即可使用了。")]),a._v(" "),n("p",[a._v("接着在调用的时候，可以指定它具体的类型为 "),n("code",[a._v("string")]),a._v("。当然，也可以不手动指定，而让类型推论自动推算出来：")]),a._v(" "),n("div",{staticClass:"language-Plain Text extra-class"},[n("pre",{pre:!0,attrs:{class:"language-plain"}},[n("code",[a._v("function createArray<T>(length: number, value: T): Array<T> {\n    let result: T[] = [];\n    for (let i = 0; i < length; i++) {\n        result[i] = value;\n    }\n    return result;\n}\n\ncreateArray(3, 'x'); // ['x', 'x', 'x']\n")])])]),n("h2",{attrs:{id:"多个类型参数"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#多个类型参数"}},[a._v("#")]),a._v(" 多个类型参数")]),a._v(" "),n("p",[a._v("定义泛型的时候，可以一次定义多个类型参数：")]),a._v(" "),n("div",{staticClass:"language-Plain Text extra-class"},[n("pre",{pre:!0,attrs:{class:"language-plain"}},[n("code",[a._v("function swap<T, U>(tuple: [T, U]): [U, T] {\n    return [tuple[1], tuple[0]];\n}\n\nswap([7, 'seven']); // ['seven', 7]\n")])])]),n("p",[a._v("上例中，我们定义了一个 "),n("code",[a._v("swap")]),a._v(" 函数，用来交换输入的元组。")]),a._v(" "),n("h2",{attrs:{id:"泛型约束"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#泛型约束"}},[a._v("#")]),a._v(" 泛型约束")]),a._v(" "),n("p",[a._v("在函数内部使用泛型变量的时候，由于事先不知道它是哪种类型，所以不能随意的操作它的属性或方法：")]),a._v(" "),n("div",{staticClass:"language-Plain Text extra-class"},[n("pre",{pre:!0,attrs:{class:"language-plain"}},[n("code",[a._v("function loggingIdentity<T>(arg: T): T {\n    console.log(arg.length);\n    return arg;\n}\n\n// index.ts(2,19): error TS2339: Property 'length' does not exist on type 'T'.\n")])])]),n("p",[a._v("上例中，泛型 "),n("code",[a._v("T")]),a._v(" 不一定包含属性 "),n("code",[a._v("length")]),a._v("，所以编译的时候报错了。")]),a._v(" "),n("p",[a._v("这时，我们可以对泛型进行约束，只允许这个函数传入那些包含 "),n("code",[a._v("length")]),a._v(" 属性的变量。这就是泛型约束：")]),a._v(" "),n("div",{staticClass:"language-Plain Text extra-class"},[n("pre",{pre:!0,attrs:{class:"language-plain"}},[n("code",[a._v("interface Lengthwise {\n    length: number;\n}\n\nfunction loggingIdentity<T extends Lengthwise>(arg: T): T {\n    console.log(arg.length);\n    return arg;\n}\n")])])]),n("p",[a._v("上例中，我们使用了 "),n("code",[a._v("extends")]),a._v(" 约束了泛型 "),n("code",[a._v("T")]),a._v(" 必须符合接口 "),n("code",[a._v("Lengthwise")]),a._v(" 的形状，也就是必须包含 "),n("code",[a._v("length")]),a._v(" 属性。")]),a._v(" "),n("p",[a._v("此时如果调用 "),n("code",[a._v("loggingIdentity")]),a._v(" 的时候，传入的 "),n("code",[a._v("arg")]),a._v(" 不包含 "),n("code",[a._v("length")]),a._v("，那么在编译阶段就会报错了：")]),a._v(" "),n("div",{staticClass:"language-Plain Text extra-class"},[n("pre",{pre:!0,attrs:{class:"language-plain"}},[n("code",[a._v("interface Lengthwise {\n    length: number;\n}\n\nfunction loggingIdentity<T extends Lengthwise>(arg: T): T {\n    console.log(arg.length);\n    return arg;\n}\n\nloggingIdentity(7);\n\n// index.ts(10,17): error TS2345: Argument of type '7' is not assignable to parameter of type 'Lengthwise'.\n")])])]),n("p",[a._v("多个类型参数之间也可以互相约束：")]),a._v(" "),n("div",{staticClass:"language-Plain Text extra-class"},[n("pre",{pre:!0,attrs:{class:"language-plain"}},[n("code",[a._v("function copyFields<T extends U, U>(target: T, source: U): T {\n    for (let id in source) {\n        target[id] = (<T>source)[id];\n    }\n    return target;\n}\n\nlet x = { a: 1, b: 2, c: 3, d: 4 };\n\ncopyFields(x, { b: 10, d: 20 });\n")])])]),n("p",[a._v("上例中，我们使用了两个类型参数，其中要求 "),n("code",[a._v("T")]),a._v(" 继承 "),n("code",[a._v("U")]),a._v("，这样就保证了 "),n("code",[a._v("U")]),a._v(" 上不会出现 "),n("code",[a._v("T")]),a._v(" 中不存在的字段。")]),a._v(" "),n("h2",{attrs:{id:"泛型接口"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#泛型接口"}},[a._v("#")]),a._v(" 泛型接口")]),a._v(" "),n("p",[a._v("可以使用接口的方式来定义一个函数需要符合的形状：")]),a._v(" "),n("div",{staticClass:"language-Plain Text extra-class"},[n("pre",{pre:!0,attrs:{class:"language-plain"}},[n("code",[a._v("interface SearchFunc {\n  (source: string, subString: string): boolean;\n}\n\nlet mySearch: SearchFunc;\nmySearch = function(source: string, subString: string) {\n    return source.search(subString) !== -1;\n}\n")])])]),n("p",[a._v("当然也可以使用含有泛型的接口来定义函数的形状：")]),a._v(" "),n("div",{staticClass:"language-Plain Text extra-class"},[n("pre",{pre:!0,attrs:{class:"language-plain"}},[n("code",[a._v("interface CreateArrayFunc {\n    <T>(length: number, value: T): Array<T>;\n}\n\nlet createArray: CreateArrayFunc;\ncreateArray = function<T>(length: number, value: T): Array<T> {\n    let result: T[] = [];\n    for (let i = 0; i < length; i++) {\n        result[i] = value;\n    }\n    return result;\n}\n\ncreateArray(3, 'x'); // ['x', 'x', 'x']\n")])])]),n("p",[a._v("进一步，我们可以把泛型参数提前到接口名上：")]),a._v(" "),n("div",{staticClass:"language-Plain Text extra-class"},[n("pre",{pre:!0,attrs:{class:"language-plain"}},[n("code",[a._v("interface CreateArrayFunc<T> {\n    (length: number, value: T): Array<T>;\n}\n\nlet createArray: CreateArrayFunc<any>;\ncreateArray = function<T>(length: number, value: T): Array<T> {\n    let result: T[] = [];\n    for (let i = 0; i < length; i++) {\n        result[i] = value;\n    }\n    return result;\n}\n\ncreateArray(3, 'x'); // ['x', 'x', 'x']\n")])])]),n("p",[a._v("注意，此时在使用泛型接口的时候，需要定义泛型的类型。")]),a._v(" "),n("h2",{attrs:{id:"泛型类"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#泛型类"}},[a._v("#")]),a._v(" 泛型类")]),a._v(" "),n("p",[a._v("与泛型接口类似，泛型也可以用于类的类型定义中：")]),a._v(" "),n("div",{staticClass:"language-Plain Text extra-class"},[n("pre",{pre:!0,attrs:{class:"language-plain"}},[n("code",[a._v("class GenericNumber<T> {\n    zeroValue: T;\n    add: (x: T, y: T) => T;\n}\n\nlet myGenericNumber = new GenericNumber<number>();\nmyGenericNumber.zeroValue = 0;\nmyGenericNumber.add = function(x, y) { return x + y; };\n")])])]),n("h2",{attrs:{id:"泛型参数的默认类型"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#泛型参数的默认类型"}},[a._v("#")]),a._v(" 泛型参数的默认类型")]),a._v(" "),n("p",[a._v("在 TypeScript 2.3 以后，我们可以为泛型中的类型参数指定默认类型。当使用泛型时没有在代码中直接指定类型参数，从实际值参数中也无法推测出时，这个默认类型就会起作用。")]),a._v(" "),n("div",{staticClass:"language-Plain Text extra-class"},[n("pre",{pre:!0,attrs:{class:"language-plain"}},[n("code",[a._v("function createArray<T = string>(length: number, value: T): Array<T> {\n    let result: T[] = [];\n    for (let i = 0; i < length; i++) {\n        result[i] = value;\n    }\n    return result;\n}\n")])])]),n("h1",{attrs:{id:"声明合并"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#声明合并"}},[a._v("#")]),a._v(" 声明合并")]),a._v(" "),n("p",[a._v("如果定义了两个相同名字的函数、接口或类，那么它们会合并成一个类型：")]),a._v(" "),n("h2",{attrs:{id:"函数的合并"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#函数的合并"}},[a._v("#")]),a._v(" 函数的合并")]),a._v(" "),n("p",[a._v("我们可以使用重载定义多个函数类型：")]),a._v(" "),n("div",{staticClass:"language-Plain Text extra-class"},[n("pre",{pre:!0,attrs:{class:"language-plain"}},[n("code",[a._v("function reverse(x: number): number;\nfunction reverse(x: string): string;\nfunction reverse(x: number | string): number | string {\n    if (typeof x === 'number') {\n        return Number(x.toString().split('').reverse().join(''));\n    } else if (typeof x === 'string') {\n        return x.split('').reverse().join('');\n    }\n}\n")])])]),n("h2",{attrs:{id:"接口的合并"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#接口的合并"}},[a._v("#")]),a._v(" 接口的合并")]),a._v(" "),n("p",[a._v("接口中的属性在合并时会简单的合并到一个接口中：")]),a._v(" "),n("div",{staticClass:"language-Plain Text extra-class"},[n("pre",{pre:!0,attrs:{class:"language-plain"}},[n("code",[a._v("interface Alarm {\n    price: number;\n}\ninterface Alarm {\n    weight: number;\n}\n")])])]),n("p",[a._v("相当于：")]),a._v(" "),n("div",{staticClass:"language-Plain Text extra-class"},[n("pre",{pre:!0,attrs:{class:"language-plain"}},[n("code",[a._v("interface Alarm {\n    price: number;\n    weight: number;\n}\n")])])]),n("p",[a._v("注意，"),n("strong",[a._v("合并的属性的类型必须是唯一的")]),a._v("：")]),a._v(" "),n("div",{staticClass:"language-Plain Text extra-class"},[n("pre",{pre:!0,attrs:{class:"language-plain"}},[n("code",[a._v("interface Alarm {\n    price: number;\n}\ninterface Alarm {\n    price: number;  // 虽然重复了，但是类型都是 `number`，所以不会报错\n    weight: number;\n}\n")])])]),n("div",{staticClass:"language-Plain Text extra-class"},[n("pre",{pre:!0,attrs:{class:"language-plain"}},[n("code",[a._v("interface Alarm {\n    price: number;\n}\ninterface Alarm {\n    price: string;  // 类型不一致，会报错\n    weight: number;\n}\n\n// index.ts(5,3): error TS2403: Subsequent variable declarations must have the same type.  Variable 'price' must be of type 'number', but here has type 'string'.\n")])])]),n("p",[a._v("接口中方法的合并，与函数的合并一样：")]),a._v(" "),n("div",{staticClass:"language-Plain Text extra-class"},[n("pre",{pre:!0,attrs:{class:"language-plain"}},[n("code",[a._v("interface Alarm {\n    price: number;\n    alert(s: string): string;\n}\ninterface Alarm {\n    weight: number;\n    alert(s: string, n: number): string;\n}\n")])])]),n("p",[a._v("相当于：")]),a._v(" "),n("div",{staticClass:"language-Plain Text extra-class"},[n("pre",{pre:!0,attrs:{class:"language-plain"}},[n("code",[a._v("interface Alarm {\n    price: number;\n    weight: number;\n    alert(s: string): string;\n    alert(s: string, n: number): string;\n}\n")])])]),n("h2",{attrs:{id:"类的合并"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#类的合并"}},[a._v("#")]),a._v(" 类的合并")]),a._v(" "),n("p",[a._v("类的合并与接口的合并规则一致。")])])}),[],!1,null,null,null);n.default=e.exports}}]);